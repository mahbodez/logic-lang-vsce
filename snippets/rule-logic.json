{
  "Define Variable": {
    "prefix": "define",
    "body": [
      "define ${1:variable_name} = ${2:expression}"
    ],
    "description": "Define a new variable"
  },
  "Define Constant": {
    "prefix": "const",
    "body": [
      "const ${1:constant_name} = ${2:value}"
    ],
    "description": "Define a constant value"
  },
  "Expect Single Variable": {
    "prefix": "expect",
    "body": [
      "expect ${1:variable_name}"
    ],
    "description": "Declare a single expected variable"
  },
  "Expect Single Variable with Alias": {
    "prefix": "expect_as",
    "body": [
      "expect ${1:variable_name} as ${2:alias_name}"
    ],
    "description": "Declare a single expected variable with an alias"
  },
  "Expect Multiple Variables": {
    "prefix": "expect_multi",
    "body": [
      "expect ${1:variable1}, ${2:variable2}, ${3:variable3}"
    ],
    "description": "Declare multiple expected variables"
  },
  "Expect Multiple Variables with Aliases": {
    "prefix": "expect_multi_as",
    "body": [
      "expect ${1:variable1} as ${2:alias1}, ${3:variable2}, ${4:variable3} as ${5:alias3}"
    ],
    "description": "Declare multiple expected variables with some aliases"
  },
  "Expect Variables Section": {
    "prefix": "expect_section",
    "body": [
      "# Expected Variables",
      "# ==================",
      "",
      "expect ${1:mass_L}, ${2:mass_R}, ${3:mc_L}, ${4:mc_R}",
      "expect ${5:birads_L}, ${6:birads_R}, ${7:comp}",
      ""
    ],
    "description": "Complete expected variables section"
  },
  "Expect Variables Section with Aliases": {
    "prefix": "expect_section_as",
    "body": [
      "# Expected Variables with Aliases",
      "# ===============================",
      "",
      "expect ${1:mass_L} as ${2:left_mass}, ${3:mass_R} as ${4:right_mass}",
      "expect ${5:birads_L} as ${6:left_birads}, ${7:birads_R} as ${8:right_birads}",
      "expect ${9:comp} as ${10:composition}",
      ""
    ],
    "description": "Complete expected variables section with aliases"
  },
  "Basic Constraint": {
    "prefix": "constraint",
    "body": [
      "constraint ${1:expression} weight=${2:1.0} transform=\"${3:logbarrier}\""
    ],
    "description": "Create a basic constraint"
  },
  "Exactly One Constraint": {
    "prefix": "exactly_one",
    "body": [
      "constraint exactly_one(${1:probabilities}) weight=${2:1.0} transform=\"${3:logbarrier}\""
    ],
    "description": "Create exactly-one constraint for categorical probabilities"
  },
  "At Least K Constraint": {
    "prefix": "at_least_k",
    "body": [
      "constraint at_least_k(${1:probabilities}, ${2:k}) weight=${3:0.6} transform=\"${4:logbarrier}\""
    ],
    "description": "Create at-least-k constraint"
  },
  "At Most K Constraint": {
    "prefix": "at_most_k",
    "body": [
      "constraint at_most_k(${1:probabilities}, ${2:k}) weight=${3:0.7} transform=\"${4:logbarrier}\""
    ],
    "description": "Create at-most-k constraint"
  },
  "Exactly K Constraint": {
    "prefix": "exactly_k",
    "body": [
      "constraint exactly_k(${1:probabilities}, ${2:k}) weight=${3:0.8} transform=\"${4:logbarrier}\""
    ],
    "description": "Create exactly-k constraint"
  },
  "Implication Constraint": {
    "prefix": "implies",
    "body": [
      "constraint ${1:antecedent} >> ${2:consequent} weight=${3:0.7} transform=\"${4:logbarrier}\""
    ],
    "description": "Create implication constraint (if A then B)"
  },
  "Threshold Implication": {
    "prefix": "threshold_implication",
    "body": [
      "constraint threshold_implication(${1:antecedent}, ${2:consequent}, ${3:0.7}) weight=${4:0.9} transform=\"${5:logbarrier}\""
    ],
    "description": "Create threshold-based implication constraint"
  },
  "Conditional Probability": {
    "prefix": "conditional_probability",
    "body": [
      "constraint conditional_probability(${1:condition}, ${2:event}, ${3:0.85}) weight=${4:0.8} transform=\"${5:logbarrier}\""
    ],
    "description": "Create conditional probability constraint"
  },
  "Sum Function": {
    "prefix": "sum",
    "body": [
      "sum(${1:probabilities}, [${2:indices}])"
    ],
    "description": "Sum probabilities for specified class indices"
  },
  "Mutual Exclusion": {
    "prefix": "mutual_exclusion",
    "body": [
      "constraint mutual_exclusion(${1:prob1}, ${2:prob2}) weight=${3:0.5} transform=\"${4:logbarrier}\""
    ],
    "description": "Create mutual exclusion constraint"
  },
  "Greater Than": {
    "prefix": "greater_than",
    "body": [
      "greater_than(${1:left}, ${2:right})"
    ],
    "description": "Soft greater than comparison"
  },
  "Less Than": {
    "prefix": "less_than",
    "body": [
      "less_than(${1:left}, ${2:right})"
    ],
    "description": "Soft less than comparison"
  },
  "Equals": {
    "prefix": "equals",
    "body": [
      "equals(${1:left}, ${2:right})"
    ],
    "description": "Soft equality comparison"
  },
  "Threshold Constraint": {
    "prefix": "threshold_constraint",
    "body": [
      "threshold_constraint(${1:tensor}, ${2:threshold}, \"${3:>}\")"
    ],
    "description": "Threshold constraint with comparison operator"
  },
  "Clamp Function": {
    "prefix": "clamp",
    "body": [
      "clamp(${1:tensor}, ${2:min_val}, ${3:max_val})"
    ],
    "description": "Clamp tensor values to range"
  },
  "Threshold Function": {
    "prefix": "threshold",
    "body": [
      "threshold(${1:tensor}, ${2:threshold_val})"
    ],
    "description": "Apply threshold to tensor"
  },
  "Comparison Greater": {
    "prefix": "greater",
    "body": [
      "${1:variable} > ${2:threshold}"
    ],
    "description": "Greater than comparison"
  },
  "Comparison Less": {
    "prefix": "less",
    "body": [
      "${1:variable} < ${2:threshold}"
    ],
    "description": "Less than comparison"
  },
  "Comparison Equal": {
    "prefix": "equal",
    "body": [
      "${1:variable} == ${2:value}"
    ],
    "description": "Equality comparison"
  },
  "Addition": {
    "prefix": "add",
    "body": [
      "${1:variable1} + ${2:variable2}"
    ],
    "description": "Addition operation"
  },
  "Subtraction": {
    "prefix": "subtract",
    "body": [
      "${1:variable1} - ${2:variable2}"
    ],
    "description": "Subtraction operation"
  },
  "Multiplication": {
    "prefix": "multiply",
    "body": [
      "${1:variable1} * ${2:variable2}"
    ],
    "description": "Multiplication operation"
  },
  "Division": {
    "prefix": "divide",
    "body": [
      "${1:variable1} / ${2:variable2}"
    ],
    "description": "Division operation"
  },
  "Arithmetic Expression": {
    "prefix": "arithmetic",
    "body": [
      "(${1:a} + ${2:b}) * ${3:factor} - ${4:offset}"
    ],
    "description": "Complex arithmetic expression with multiple operations"
  },
  "Range Constraint": {
    "prefix": "range",
    "body": [
      "(${1:variable} >= ${2:min_val}) & (${1:variable} <= ${3:max_val})"
    ],
    "description": "Range constraint with min and max values"
  },
  "Tensor Indexing": {
    "prefix": "index",
    "body": [
      "${1:tensor}[${2:index}]"
    ],
    "description": "Tensor indexing"
  },
  "Tensor Slicing": {
    "prefix": "slice",
    "body": [
      "${1:tensor}[${2:start}:${3:end}]"
    ],
    "description": "Tensor slicing"
  },
  "Multi-dimensional Index": {
    "prefix": "multi_index",
    "body": [
      "${1:tensor}[${2:dim1}, ${3:dim2}]"
    ],
    "description": "Multi-dimensional tensor indexing"
  },
  "AND across tensor": {
    "prefix": "and_tensor",
    "body": [
      "& ${1:tensor_variable}"
    ],
    "description": "AND operation across all elements in tensor"
  },
  "OR across tensor": {
    "prefix": "or_tensor",
    "body": [
      "| ${1:tensor_variable}"
    ],
    "description": "OR operation across all elements in tensor"
  },
  "Comment Block": {
    "prefix": "comment",
    "body": [
      "# ${1:Comment description}",
      "# $2"
    ],
    "description": "Add comment block"
  },
  "Constants Section": {
    "prefix": "constants",
    "body": [
      "# Constants",
      "# =========",
      "",
      "const ${1:threshold_name} = ${2:0.7}",
      "const ${3:cutoff_name} = ${4:4}",
      "const ${5:range_min} = ${6:0.1}",
      "const ${7:range_max} = ${8:0.9}"
    ],
    "description": "Constants section template"
  },
  "Mammography Rule Template": {
    "prefix": "mammo_template",
    "body": [
      "# Mammography Constraint Rules",
      "# ============================",
      "",
      "# Declare expected variables from model output",
      "expect mass_L, mass_R, mc_L, mc_R",
      "expect birads_L, birads_R, birads_score_L, birads_score_R",
      "expect comp",
      "",
      "# Define constants for reusable thresholds",
      "const high_risk_threshold = 0.7",
      "const low_risk_threshold = 0.3",
      "const birads_high_cutoff = 4",
      "",
      "# Feature definitions - combine findings per breast",
      "define findings_L = mass_L | mc_L",
      "define findings_R = mass_R | mc_R",
      "",
      "# BI-RADS probability groups using constants",
      "define high_birads_L = sum(birads_L, [4, 5, 6])",
      "define high_birads_R = sum(birads_R, [4, 5, 6])",
      "",
      "# Threshold-based risk assessments",
      "define high_risk_L = birads_score_L > high_risk_threshold",
      "define high_risk_R = birads_score_R > high_risk_threshold",
      "",
      "# Range constraints",
      "define valid_range_L = (birads_score_L >= 0.0) & (birads_score_L <= 1.0)",
      "define valid_range_R = (birads_score_R >= 0.0) & (birads_score_R <= 1.0)",
      "",
      "# Categorical exclusivity constraints",
      "constraint exactly_one(birads_L) weight=1.0 transform=\"logbarrier\"",
      "constraint exactly_one(birads_R) weight=1.0 transform=\"logbarrier\"",
      "constraint exactly_one(comp) weight=0.7 transform=\"logbarrier\"",
      "",
      "# Logical implication constraints",
      "constraint high_risk_L >> findings_L weight=0.8 transform=\"logbarrier\"",
      "constraint high_risk_R >> findings_R weight=0.8 transform=\"logbarrier\"",
      "",
      "# Range validation constraints",
      "constraint valid_range_L weight=2.0 transform=\"logbarrier\"",
      "constraint valid_range_R weight=2.0 transform=\"logbarrier\""
    ],
    "description": "Complete mammography rule template with expect declarations"
  },
  "Multiple Statements (Semicolon)": {
    "prefix": "multi_statements",
    "body": [
      "expect ${1:var1}, ${2:var2}; define ${3:result} = ${1:var1} | ${2:var2}; constraint ${3:result}"
    ],
    "description": "Multiple statements on one line using semicolons"
  },
  "Constants with Semicolons": {
    "prefix": "const_multi",
    "body": [
      "const ${1:low} = ${2:0.2}; const ${3:high} = ${4:0.8}; define ${5:range_check} = ${6:value} >= ${1:low} & ${6:value} <= ${3:high}"
    ],
    "description": "Multiple constants and definition using semicolons"
  },
  "Expect and Define": {
    "prefix": "expect_define",
    "body": [
      "expect ${1:variable}; define ${2:result} = ${1:variable} ${3:operator} ${4:threshold}"
    ],
    "description": "Expect variable and define result using semicolon"
  },
  "Expect with Alias and Define": {
    "prefix": "expect_define_as",
    "body": [
      "expect ${1:variable} as ${2:alias}; define ${3:result} = ${2:alias} ${4:operator} ${5:threshold}"
    ],
    "description": "Expect variable with alias and define result using the alias"
  },
  "Quick Setup": {
    "prefix": "quick_setup",
    "body": [
      "const ${1:threshold} = ${2:0.5}; expect ${3:risk_score}; define ${4:high_risk} = ${3:risk_score} > ${1:threshold}; constraint ${4:high_risk} weight=${5:0.8}"
    ],
    "description": "Quick setup with constant, expect, define, and constraint"
  }
}